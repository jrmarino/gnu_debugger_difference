--- /dev/null
+++ gdb/amd64-dfly-nat.c
@@ -0,0 +1,317 @@
+/* Native-dependent code for DragonFly/amd64.
+
+   Copyright (C) 2003-2019 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "inferior.h"
+#include "regcache.h"
+#include "target.h"
+#include "gregset.h"
+
+#include <signal.h>
+#include <stddef.h>
+#include <sys/types.h>
+#include <sys/procfs.h>
+#include <sys/ptrace.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <machine/reg.h>
+#include <machine/segments.h>
+
+#include "dfly-nat.h"
+#include "amd64-tdep.h"
+#include "amd64-nat.h"
+#include "amd64-bsd-nat.h"
+#include "x86-nat.h"
+#include "gdbsupport/x86-xstate.h"
+
+
+class amd64_dfly_nat_target final
+  : public amd64_bsd_nat_target<dfly_nat_target>
+{
+public:
+  /* Add some extra features to the common *BSD/amd64 target.  */
+  const struct target_desc *read_description () override;
+
+};
+
+static amd64_dfly_nat_target the_amd64_dfly_nat_target;
+
+/* Offset in `struct reg' where MEMBER is stored.  */
+#define REG_OFFSET(member) offsetof (struct reg, member)
+
+/* At amd64dfly64_r_reg_offset[REGNUM] you'll find the offset in
+   `struct reg' location where the GDB register REGNUM is stored.
+   Unsupported registers are marked with `-1'.  */
+static int amd64dfly64_r_reg_offset[] =
+{
+  REG_OFFSET (r_rax),
+  REG_OFFSET (r_rbx),
+  REG_OFFSET (r_rcx),
+  REG_OFFSET (r_rdx),
+  REG_OFFSET (r_rsi),
+  REG_OFFSET (r_rdi),
+  REG_OFFSET (r_rbp),
+  REG_OFFSET (r_rsp),
+  REG_OFFSET (r_r8),
+  REG_OFFSET (r_r9),
+  REG_OFFSET (r_r10),
+  REG_OFFSET (r_r11),
+  REG_OFFSET (r_r12),
+  REG_OFFSET (r_r13),
+  REG_OFFSET (r_r14),
+  REG_OFFSET (r_r15),
+  REG_OFFSET (r_rip),
+  REG_OFFSET (r_rflags),
+  REG_OFFSET (r_cs),
+  REG_OFFSET (r_ss),
+  -1,
+  -1,
+  -1,
+  -1
+};
+
+
+/* Mapping between the general-purpose registers in DragonFly/amd64
+   `struct reg' format and GDB's register cache layout for
+   DragonFly/x86.
+
+   Note that most DragonFly/amd64 registers are 64-bit, while the
+   DragonFly/x86 registers are all 32-bit, but since we're
+   little-endian we get away with that.  */
+
+/* From <machine/reg.h>.  */
+static int amd64dfly32_r_reg_offset[I386_NUM_GREGS] =
+{
+  14 * 8, 13 * 8,		/* %eax, %ecx */
+  12 * 8, 11 * 8,		/* %edx, %ebx */
+  20 * 8, 10 * 8,		/* %esp, %ebp */
+  9 * 8, 8 * 8,			/* %esi, %edi */
+  17 * 8, 19 * 8,		/* %eip, %eflags */
+  18 * 8, 21 * 8,		/* %cs, %ss */
+  -1, -1, -1, -1		/* %ds, %es, %fs, %gs */
+};
+
+
+#ifdef DFLY_PCB_SUPPLY
+/* Transfering the registers between GDB, inferiors and core files.  */
+
+/* Fill GDB's register array with the general-purpose register values
+   in *GREGSETP.  */
+
+void
+supply_gregset (struct regcache *regcache, const gregset_t *gregsetp)
+{
+  amd64_supply_native_gregset (regcache, gregsetp, -1);
+}
+
+/* Fill register REGNUM (if it is a general-purpose register) in
+   *GREGSETPS with the value in GDB's register array.  If REGNUM is -1,
+   do this for all registers.  */
+
+void
+fill_gregset (const struct regcache *regcache, gdb_gregset_t *gregsetp, int regnum)
+{
+  amd64_collect_native_gregset (regcache, gregsetp, regnum);
+}
+
+/* Fill GDB's register array with the floating-point register values
+   in *FPREGSETP.  */
+
+void
+supply_fpregset (struct regcache *regcache, const fpregset_t *fpregsetp)
+{
+  amd64_supply_fxsave (regcache, -1, fpregsetp);
+}
+
+/* Fill register REGNUM (if it is a floating-point register) in
+   *FPREGSETP with the value in GDB's register array.  If REGNUM is -1,
+   do this for all registers.  */
+
+void
+fill_fpregset (const struct regcache *regcache, gdb_fpregset_t *fpregsetp, int regnum)
+{
+  amd64_collect_fxsave (regcache, regnum, fpregsetp);
+}
+
+/* Support for debugging kernel virtual memory images.  */
+
+#include <sys/types.h>
+#include <machine/pcb.h>
+#include <osreldate.h>
+
+#include "bsd-kvm.h"
+
+static int
+amd64dfly_supply_pcb (struct regcache *regcache, struct pcb *pcb)
+{
+  /* The following is true for FreeBSD 5.2:
+
+     The pcb contains %rip, %rbx, %rsp, %rbp, %r12, %r13, %r14, %r15,
+     %ds, %es, %fs and %gs.  This accounts for all callee-saved
+     registers specified by the psABI and then some.  Here %esp
+     contains the stack pointer at the point just after the call to
+     cpu_switch().  From this information we reconstruct the register
+     state as it would like when we just returned from cpu_switch().  */
+
+  /* The stack pointer shouldn't be zero.  */
+  if (pcb->pcb_rsp == 0)
+    return 0;
+
+  pcb->pcb_rsp += 8;
+  regcache->raw_supply (AMD64_RIP_REGNUM, &pcb->pcb_rip);
+  regcache->raw_supply (AMD64_RBX_REGNUM, &pcb->pcb_rbx);
+  regcache->raw_supply (AMD64_RSP_REGNUM, &pcb->pcb_rsp);
+  regcache->raw_supply (AMD64_RBP_REGNUM, &pcb->pcb_rbp);
+  regcache->raw_supply (12, &pcb->pcb_r12);
+  regcache->raw_supply (13, &pcb->pcb_r13);
+  regcache->raw_supply (14, &pcb->pcb_r14);
+  regcache->raw_supply (15, &pcb->pcb_r15);
+
+  return 1;
+}
+#endif /* DFLY_PCB_SUPPLY */
+
+
+/* Implement the read_description method.  */
+
+const struct target_desc *
+amd64_dfly_nat_target::read_description ()
+{
+#ifdef PT_GETXSTATE_INFO
+  static int xsave_probed;
+  static uint64_t xcr0;
+#endif
+  struct reg regs;
+  int is64;
+
+  if (ptrace (PT_GETREGS, inferior_ptid.pid (),
+	      (PTRACE_TYPE_ARG3) &regs, 0) == -1)
+    perror_with_name (_("Couldn't get registers"));
+  is64 = (regs.r_cs == GSEL (GUCODE_SEL, SEL_UPL));
+#ifdef PT_GETXSTATE_INFO
+  if (!xsave_probed)
+    {
+      struct ptrace_xstate_info info;
+
+      if (ptrace (PT_GETXSTATE_INFO, inferior_ptid.pid (),
+		  (PTRACE_TYPE_ARG3) &info, sizeof (info)) == 0)
+	{
+	  x86bsd_xsave_len = info.xsave_len;
+	  xcr0 = info.xsave_mask;
+	}
+      xsave_probed = 1;
+    }
+
+  if (x86bsd_xsave_len != 0)
+    {
+      if (is64)
+	return amd64_target_description (xcr0, true);
+      else
+	return i386_target_description (xcr0, true);
+    }
+#endif
+  if (is64)
+    return amd64_target_description (X86_XSTATE_SSE_MASK, true);
+  else
+    return i386_target_description (X86_XSTATE_SSE_MASK, true);
+}
+
+
+void
+_initialize_amd64dfly_nat (void)
+{
+  int offset;
+
+  amd64_native_gregset32_reg_offset = amd64dfly32_r_reg_offset;
+  amd64_native_gregset64_reg_offset = amd64dfly64_r_reg_offset;
+
+  add_inf_child_target (&the_amd64_dfly_nat_target);
+
+#ifdef DFLY_PCB_SUPPLY
+  /* Support debugging kernel virtual memory images.  */
+  bsd_kvm_add_target (amd64dfly_supply_pcb);
+#endif
+
+  /* To support the recognition of signal handlers, i386-bsd-tdep.c
+     hardcodes some constants.  Inclusion of this file means that we
+     are compiling a native debugger, which means that we can use the
+     system header files and sysctl(3) to get at the relevant
+     information.  */
+
+#define SC_REG_OFFSET amd64dfly_sc_reg_offset
+
+  /* We only check the program counter, stack pointer and frame
+     pointer since these members of `struct sigcontext' are essential
+     for providing backtraces.  */
+
+#define SC_RIP_OFFSET SC_REG_OFFSET[AMD64_RIP_REGNUM]
+#define SC_RSP_OFFSET SC_REG_OFFSET[AMD64_RSP_REGNUM]
+#define SC_RBP_OFFSET SC_REG_OFFSET[AMD64_RBP_REGNUM]
+
+  /* Override the default value for the offset of the program counter
+     in the sigcontext structure.  */
+  offset = offsetof (struct sigcontext, sc_rip);
+
+  if (SC_RIP_OFFSET != offset)
+    {
+      warning (_("\
+offsetof (struct sigcontext, sc_rip) yields %d instead of %d.\n\
+Please report this to <bug-gdb@gnu.org>."),
+	       offset, SC_RIP_OFFSET);
+    }
+
+  SC_RIP_OFFSET = offset;
+
+  /* Likewise for the stack pointer.  */
+  offset = offsetof (struct sigcontext, sc_rsp);
+
+  if (SC_RSP_OFFSET != offset)
+    {
+      warning (_("\
+offsetof (struct sigcontext, sc_rsp) yields %d instead of %d.\n\
+Please report this to <bug-gdb@gnu.org>."),
+	       offset, SC_RSP_OFFSET);
+    }
+
+  SC_RSP_OFFSET = offset;
+
+  /* And the frame pointer.  */
+  offset = offsetof (struct sigcontext, sc_rbp);
+
+  if (SC_RBP_OFFSET != offset)
+    {
+      warning (_("\
+offsetof (struct sigcontext, sc_rbp) yields %d instead of %d.\n\
+Please report this to <bug-gdb@gnu.org>."),
+	       offset, SC_RBP_OFFSET);
+    }
+
+  SC_RBP_OFFSET = offset;
+
+  {
+    struct kinfo_sigtramp kst = {0};
+    size_t len = sizeof (kst);
+    int mib[3] = { CTL_KERN, KERN_PROC, KERN_PROC_SIGTRAMP };
+    if (sysctl (mib, 3, &kst, &len, NULL, 0) == 0)
+      {
+        amd64dfly_sigtramp_start_addr = (uintptr_t) kst.ksigtramp_start;
+        amd64dfly_sigtramp_end_addr   = (uintptr_t) kst.ksigtramp_end;
+      }
+  }
+}
--- /dev/null
+++ gdb/amd64-dfly-tdep.c
@@ -0,0 +1,185 @@
+/* Target-dependent code for DragonFly/amd64.
+
+   Copyright (C) 2003-2019 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "arch-utils.h"
+#include "frame.h"
+#include "gdbcore.h"
+#include "regcache.h"
+#include "osabi.h"
+#include "regset.h"
+#include "gdbsupport/x86-xstate.h"
+
+#include <string.h>
+
+#include "amd64-tdep.h"
+#include "dfly-tdep.h"
+#include "solib-svr4.h"
+
+/* Support for signal handlers.  */
+
+
+/* Assuming THIS_FRAME is for a BSD sigtramp routine, return the
+   address of the associated sigcontext structure.  */
+
+static CORE_ADDR
+amd64dfly_sigcontext_addr (struct frame_info *this_frame)
+{
+  struct gdbarch *gdbarch = get_frame_arch (this_frame);
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
+  CORE_ADDR sp;
+  gdb_byte buf[8];
+
+  /* The `struct sigcontext' (which really is an `ucontext_t' on
+     DragonFly/amd64) lives at a fixed offset in the signal frame.  See
+     <machine/sigframe.h>.  */
+  get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);
+  sp = extract_unsigned_integer (buf, 8, byte_order);
+  return sp + 16;
+}
+
+/* Mapping between the general-purpose registers in `struct reg'
+   format and GDB's register cache layout.
+
+   Note that some registers are 32-bit, but since we're little-endian
+   we get away with that.  */
+
+/* From <machine/reg.h>.  */
+static int amd64dfly_r_reg_offset[] =
+{
+  6 * 8,			/* %rax */
+  7 * 8,			/* %rbx */
+  3 * 8,			/* %rcx */
+  2 * 8,			/* %rdx */
+  1 * 8,			/* %rsi */
+  0 * 8,			/* %rdi */
+  8 * 8,			/* %rbp */
+  23 * 8,			/* %rsp */
+  4 * 8,			/* %r8 ... */
+  5 * 8,
+  9 * 8,
+  10 * 8,
+  11 * 8,
+  12 * 8,
+  13 * 8,
+  14 * 8,			/* ... %r15 */
+  20 * 8,			/* %rip */
+  22 * 8,			/* %eflags */
+  21 * 8,			/* %cs */
+  24 * 8,			/* %ss */
+  -1,				/* %ds */
+  -1,				/* %es */
+  -1,				/* %fs */
+  -1				/* %gs */
+};
+
+/* Location of the signal trampoline.  */
+CORE_ADDR amd64dfly_sigtramp_start_addr = 0x7fffffffffc0ULL;
+CORE_ADDR amd64dfly_sigtramp_end_addr = 0x7fffffffffe0ULL;
+
+/* From <machine/signal.h>.  */
+int amd64dfly_sc_reg_offset[] =
+{
+  24 + 6 * 8,			/* %rax */
+  24 + 7 * 8,			/* %rbx */
+  24 + 3 * 8,			/* %rcx */
+  24 + 2 * 8,			/* %rdx */
+  24 + 1 * 8,			/* %rsi */
+  24 + 0 * 8,			/* %rdi */
+  24 + 8 * 8,			/* %rbp */
+  24 + 23 * 8,			/* %rsp */
+  24 + 4 * 8,			/* %r8 ... */
+  24 + 5 * 8,
+  24 + 9 * 8,
+  24 + 10 * 8,
+  24 + 11 * 8,
+  24 + 12 * 8,
+  24 + 13 * 8,
+  24 + 14 * 8,			/* ... %r15 */
+  24 + 20 * 8,			/* %rip */
+  24 + 22 * 8,			/* %eflags */
+  24 + 21 * 8,			/* %cs */
+  24 + 24 * 8,			/* %ss */
+  -1,				/* %ds */
+  -1,				/* %es */
+  -1,				/* %fs */
+  -1				/* %gs */
+};
+
+/* From /usr/src/lib/libc/amd64/gen/_setjmp.S.  */
+static int amd64dfly_jmp_buf_reg_offset[] =
+{
+  -1,				/* %rax */
+  1 * 8,			/* %rbx */
+  -1,				/* %rcx */
+  -1,				/* %rdx */
+  -1,				/* %rsi */
+  -1,				/* %rdi */
+  3 * 8,			/* %rbp */
+  2 * 8,			/* %rsp */
+  -1,				/* %r8 ... */
+  -1,
+  -1,
+  -1,				/* ... %r11 */
+  4 * 8,			/* %r12 ... */
+  5 * 8,
+  6 * 8,
+  7 * 8,			/* ... %r15 */
+  0 * 8				/* %rip */
+};
+
+static void
+amd64dfly_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  /* Generic DragonFly support. */
+  dfly_init_abi (info, gdbarch);
+
+  /* Obviously DragonFly is BSD-based.  */
+  i386bsd_init_abi (info, gdbarch);
+
+  tdep->gregset_reg_offset = amd64dfly_r_reg_offset;
+  tdep->gregset_num_regs = ARRAY_SIZE (amd64dfly_r_reg_offset);
+  tdep->sizeof_gregset = 25 * 8;
+
+  amd64_init_abi (info, gdbarch,
+		  amd64_target_description (X86_XSTATE_SSE_MASK, true));
+
+  tdep->sigtramp_start = amd64dfly_sigtramp_start_addr;
+  tdep->sigtramp_end = amd64dfly_sigtramp_end_addr;
+  tdep->sigcontext_addr = amd64dfly_sigcontext_addr;
+  tdep->sc_reg_offset = amd64dfly_sc_reg_offset;
+  tdep->sc_num_regs = ARRAY_SIZE (amd64dfly_sc_reg_offset);
+
+
+  /* FreeBSD uses SVR4-style shared libraries.  */
+  set_solib_svr4_fetch_link_map_offsets
+    (gdbarch, svr4_lp64_fetch_link_map_offsets);
+
+  set_gdbarch_fetch_tls_load_module_address (gdbarch,
+					     svr4_fetch_objfile_link_map);
+}
+
+void
+_initialize_amd64dfly_tdep (void)
+{
+  gdbarch_register_osabi (bfd_arch_i386, bfd_mach_x86_64,
+			  GDB_OSABI_DRAGONFLY, amd64dfly_init_abi);
+}
--- /dev/null
+++ gdb/dfly-nat.c
@@ -0,0 +1,153 @@
+/* Native-dependent code for DragonFly.
+
+   Copyright (C) 2002-2023 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "gdbsupport/block-signals.h"
+#include "gdbsupport/byte-vector.h"
+#include "gdbsupport/event-loop.h"
+#include "gdbcore.h"
+#include "inferior.h"
+#include "regcache.h"
+#include "regset.h"
+#include "gdbarch.h"
+#include "gdbcmd.h"
+#include "gdbthread.h"
+#include "gdbsupport/buildargv.h"
+#include "gdbsupport/gdb_wait.h"
+#include "inf-loop.h"
+#include "inf-ptrace.h"
+#include <sys/types.h>
+#ifdef HAVE_SYS_PROCCTL_H
+#include <sys/procctl.h>
+#endif
+#include <sys/procfs.h>
+#include <sys/ptrace.h>
+#include <sys/signal.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <libutil.h>
+
+#include "elf-bfd.h"
+#include "dfly-nat.h"
+#include "dfly-tdep.h"
+
+#include <list>
+
+/* Return the name of a file that can be opened to get the symbols for
+   the child process identified by PID.  */
+
+const char *
+dfly_nat_target::pid_to_exec_file (int pid)
+{
+  static char buf[PATH_MAX];
+  size_t buflen;
+  int mib[4];
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PROC;
+  mib[2] = KERN_PROC_PATHNAME;
+  mib[3] = pid;
+  buflen = sizeof buf;
+  if (sysctl (mib, 4, buf, &buflen, NULL, 0) == 0)
+    /* The kern.proc.pathname.<pid> sysctl returns a length of zero
+       for processes without an associated executable such as kernel
+       processes.  */
+    return buflen == 0 ? NULL : buf;
+
+  return NULL;
+}
+
+
+static int
+dfly_read_mapping (FILE *mapfile, unsigned long *start, unsigned long *end,
+		   char *protection)
+{
+  /* FreeBSD 5.1-RELEASE uses a 256-byte buffer.  */
+  char buf[256];
+  int resident, privateresident;
+  unsigned long obj;
+  int ret = EOF;
+
+  if (fgets (buf, sizeof buf, mapfile) != NULL)
+    ret = sscanf (buf, "%lx %lx %d %d %lx %s", start, end,
+		  &resident, &privateresident, &obj, protection);
+
+  return (ret != 0 && ret != EOF);
+}
+
+
+/* Iterate over all the memory regions in the current inferior,
+   calling FUNC for each memory region.  DATA is passed as the last
+   argument to FUNC.  */
+
+int
+dfly_nat_target::find_memory_regions (find_memory_region_ftype func,
+				      void *data)
+{
+  pid_t pid = inferior_ptid.pid ();
+  unsigned long start, end, size;
+  char protection[4];
+  int read, write, exec;
+
+  std::string mapfilename = string_printf ("/proc/%ld/map", (long) pid);
+  gdb_file_up mapfile (fopen (mapfilename.c_str (), "r"));
+  if (mapfile == NULL)
+    error (_("Couldn't open %s."), mapfilename.c_str ());
+
+  if (info_verbose)
+    fprintf_filtered (gdb_stdout, 
+		      "Reading memory regions from %s\n", mapfilename.c_str ());
+
+  /* Now iterate until end-of-file.  */
+  while (dfly_read_mapping (mapfile.get (), &start, &end, &protection[0]))
+    {
+      size = end - start;
+
+      read = (strchr (protection, 'r') != 0);
+      write = (strchr (protection, 'w') != 0);
+      exec = (strchr (protection, 'x') != 0);
+
+      if (info_verbose)
+	{
+	  fprintf_filtered (gdb_stdout, 
+			    "Save segment, %ld bytes at %s (%c%c%c)\n",
+			    size, paddress (target_gdbarch (), start),
+			    read ? 'r' : '-',
+			    write ? 'w' : '-',
+			    exec ? 'x' : '-');
+	}
+
+      /* Invoke the callback function to create the corefile segment.
+	 Pass MODIFIED as true, we do not know the real modification state.  */
+      func (start, size, read, write, exec, 1, obfd);
+    }
+
+  return 0;
+}
+
+void _initialize_dfly_nat ();
+
+void
+_initialize_dfly_nat ()
+{
+  /* XXX: todo add_setshow_boolean_cmd() */
+
+  /* Install a SIGCHLD handler.  */
+  //signal (SIGCHLD, sigchld_handler);
+}
--- /dev/null
+++ gdb/dfly-nat.h
@@ -0,0 +1,35 @@
+/* Native-dependent code for DragonFly.
+
+   Copyright (C) 2004-2023 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef DFLY_NAT_H
+#define DFLY_NAT_H
+
+#include "inf-ptrace.h"
+
+
+/* A prototype DragonFly target.  */
+
+class dfly_nat_target : public inf_ptrace_target
+{
+public:
+  const char *pid_to_exec_file (int pid) override;
+
+  int find_memory_regions (find_memory_region_ftype func, void *data) override;
+
+#endif /* dfly-nat.h */
--- /dev/null
+++ gdb/dfly-tdep.c
@@ -0,0 +1,697 @@
+/* Target-dependent code for FreeBSD, architecture-independent.
+
+   Copyright (C) 2002-2023 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "auxv.h"
+#include "gdbcore.h"
+#include "inferior.h"
+#include "objfiles.h"
+#include "regcache.h"
+#include "regset.h"
+#include "gdbthread.h"
+#include "objfiles.h"
+#include "xml-syscall.h"
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include "elf-bfd.h"
+#include "dfly-tdep.h"
+#include "gcore-elf.h"
+
+/* This enum is derived from DragonFly's <sys/signal.h>.  */
+
+enum
+  {
+    DRAGONFLY_SIGHUP = 1,
+    DRAGONFLY_SIGINT = 2,
+    DRAGONFLY_SIGQUIT = 3,
+    DRAGONFLY_SIGILL = 4,
+    DRAGONFLY_SIGTRAP = 5,
+    DRAGONFLY_SIGABRT = 6,
+    DRAGONFLY_SIGEMT = 7,
+    DRAGONFLY_SIGFPE = 8,
+    DRAGONFLY_SIGKILL = 9,
+    DRAGONFLY_SIGBUS = 10,
+    DRAGONFLY_SIGSEGV = 11,
+    DRAGONFLY_SIGSYS = 12,
+    DRAGONFLY_SIGPIPE = 13,
+    DRAGONFLY_SIGALRM = 14,
+    DRAGONFLY_SIGTERM = 15,
+    DRAGONFLY_SIGURG = 16,
+    DRAGONFLY_SIGSTOP = 17,
+    DRAGONFLY_SIGTSTP = 18,
+    DRAGONFLY_SIGCONT = 19,
+    DRAGONFLY_SIGCHLD = 20,
+    DRAGONFLY_SIGTTIN = 21,
+    DRAGONFLY_SIGTTOU = 22,
+    DRAGONFLY_SIGIO = 23,
+    DRAGONFLY_SIGXCPU = 24,
+    DRAGONFLY_SIGXFSZ = 25,
+    DRAGONFLY_SIGVTALRM = 26,
+    DRAGONFLY_SIGPROF = 27,
+    DRAGONFLY_SIGWINCH = 28,
+    DRAGONFLY_SIGINFO = 29,
+    DRAGONFLY_SIGUSR1 = 30,
+    DRAGONFLY_SIGUSR2 = 31,
+    DRAGONFLY_SIGTHR = 32,
+  };
+
+/* Constants for values of si_code as defined in DragonFly's
+   <sys/_siginfo.h>.  */
+
+#define	DFLY_SI_USER		0
+#define	DFLY_SI_QUEUE		-1
+#define	DFLY_SI_TIMER		-2
+#define	DFLY_SI_ASYNCIO		-3
+#define	DFLY_SI_MESGQ		-4
+
+#define	DFLY_ILL_ILLOPC		1
+#define	DFLY_ILL_ILLOPN		2
+#define	DFLY_ILL_ILLADR		3
+#define	DFLY_ILL_ILLTRP		4
+#define	DFLY_ILL_PRVOPC		5
+#define	DFLY_ILL_PRVREG		6
+#define	DFLY_ILL_COPROC		7
+#define	DFLY_ILL_BADSTK		8
+
+#define	DFLY_BUS_ADRALN		1
+#define	DFLY_BUS_ADRERR		2
+#define	DFLY_BUS_OBJERR		3
+
+#define	DFLY_SEGV_MAPERR	1
+#define	DFLY_SEGV_ACCERR	2
+
+#define	DFLY_FPE_INTOVF		1
+#define	DFLY_FPE_INTDIV		2
+#define	DFLY_FPE_FLTDIV		3
+#define	DFLY_FPE_FLTOVF		4
+#define	DFLY_FPE_FLTUND		5
+#define	DFLY_FPE_FLTRES		6
+#define	DFLY_FPE_FLTINV		7
+#define	DFLY_FPE_FLTSUB		8
+
+#define	DFLY_TRAP_BRKPT		1
+#define	DFLY_TRAP_TRACE		2
+
+#define	DFLY_CLD_EXITED		1
+#define	DFLY_CLD_KILLED		2
+#define	DFLY_CLD_DUMPED		3
+#define	DFLY_CLD_TRAPPED	4
+#define	DFLY_CLD_STOPPED	5
+#define	DFLY_CLD_CONTINUED	6
+
+#define	DFLY_POLL_IN		1
+#define	DFLY_POLL_OUT		2
+#define	DFLY_POLL_MSG		3
+#define	DFLY_POLL_ERR		4
+#define	DFLY_POLL_PRI		5
+#define	DFLY_POLL_HUP		6
+
+/* Constants for socket address families.  These match AF_* constants
+   in <sys/socket.h>.  */
+
+#define	DFLY_AF_UNIX		1
+#define	DFLY_AF_INET		2
+#define	DFLY_AF_INET6		28
+
+/* Constants for socket types.  These match SOCK_* constants in
+   <sys/socket.h>.  */
+
+#define	DFLY_SOCK_STREAM	1
+#define	DFLY_SOCK_DGRAM		2
+#define	DFLY_SOCK_SEQPACKET	5
+
+/* Constants for IP protocols.  These match IPPROTO_* constants in
+   <netinet/in.h>.  */
+
+#define DFLY_IPPROTO_IP		0
+#define	DFLY_IPPROTO_ICMP	1
+#define	DFLY_IPPROTO_TCP	6
+#define	DFLY_IPPROTO_UDP	17
+
+/* Socket address structures.  These have the same layout on all
+   architectures.  In addition, multibyte fields such as IP
+   addresses are always stored in network byte order.  */
+
+struct dfly_sockaddr_in
+{
+  uint8_t sin_len;
+  uint8_t sin_family;
+  uint8_t sin_port[2];
+  uint8_t sin_addr[4];
+  char sin_zero[8];
+};
+
+struct dfly_sockaddr_in6
+{
+  uint8_t sin6_len;
+  uint8_t sin6_family;
+  uint8_t sin6_port[2];
+  uint32_t sin6_flowinfo;
+  uint8_t sin6_addr[16];
+  uint32_t sin6_scope_id;
+};
+
+struct dfly_sockaddr_un
+{
+  uint8_t sun_len;
+  uint8_t sun_family;
+  char sun_path[104];
+};
+
+struct dfly_gdbarch_data
+  {
+    struct type *siginfo_type = nullptr;
+  };
+
+static const registry<gdbarch>::key<dfly_gdbarch_data>
+     dfly_gdbarch_data_handle;
+
+static struct dfly_gdbarch_data *
+get_dfly_gdbarch_data (struct gdbarch *gdbarch)
+{
+  struct dfly_gdbarch_data *result = dfly_gdbarch_data_handle.get (gdbarch);
+  if (result == nullptr)
+    result = dfly_gdbarch_data_handle.emplace (gdbarch);
+  return result;
+}
+
+struct dfly_pspace_data
+{
+  /* Offsets in the runtime linker's 'Obj_Entry' structure.  */
+  LONGEST off_linkmap = 0;
+  LONGEST off_tlsindex = 0;
+  bool rtld_offsets_valid = false;
+
+  /* vDSO mapping range.  */
+  struct mem_range vdso_range {};
+
+  /* Zero if the range hasn't been searched for, > 0 if a range was
+     found, or < 0 if a range was not found.  */
+  int vdso_range_p = 0;
+};
+
+/* Per-program-space data for FreeBSD architectures.  */
+static const registry<program_space>::key<dfly_pspace_data>
+  dfly_pspace_data_handle;
+
+static struct dfly_pspace_data *
+get_dfly_pspace_data (struct program_space *pspace)
+{
+  struct dfly_pspace_data *data;
+
+  data = dfly_pspace_data_handle.get (pspace);
+  if (data == NULL)
+    data = dfly_pspace_data_handle.emplace (pspace);
+
+  return data;
+}
+
+/* Implement the "gdb_signal_from_target" gdbarch method.  */
+
+static enum gdb_signal
+dfly_gdb_signal_from_target (struct gdbarch *gdbarch, int signal)
+{
+  switch (signal)
+    {
+    case 0:
+      return GDB_SIGNAL_0;
+
+    case DRAGONFLY_SIGHUP:
+      return GDB_SIGNAL_HUP;
+
+    case DRAGONFLY_SIGINT:
+      return GDB_SIGNAL_INT;
+
+    case DRAGONFLY_SIGQUIT:
+      return GDB_SIGNAL_QUIT;
+
+    case DRAGONFLY_SIGILL:
+      return GDB_SIGNAL_ILL;
+
+    case DRAGONFLY_SIGTRAP:
+      return GDB_SIGNAL_TRAP;
+
+    case DRAGONFLY_SIGABRT:
+      return GDB_SIGNAL_ABRT;
+
+    case DRAGONFLY_SIGEMT:
+      return GDB_SIGNAL_EMT;
+
+    case DRAGONFLY_SIGFPE:
+      return GDB_SIGNAL_FPE;
+
+    case DRAGONFLY_SIGKILL:
+      return GDB_SIGNAL_KILL;
+
+    case DRAGONFLY_SIGBUS:
+      return GDB_SIGNAL_BUS;
+
+    case DRAGONFLY_SIGSEGV:
+      return GDB_SIGNAL_SEGV;
+
+    case DRAGONFLY_SIGSYS:
+      return GDB_SIGNAL_SYS;
+
+    case DRAGONFLY_SIGPIPE:
+      return GDB_SIGNAL_PIPE;
+
+    case DRAGONFLY_SIGALRM:
+      return GDB_SIGNAL_ALRM;
+
+    case DRAGONFLY_SIGTERM:
+      return GDB_SIGNAL_TERM;
+
+    case DRAGONFLY_SIGURG:
+      return GDB_SIGNAL_URG;
+
+    case DRAGONFLY_SIGSTOP:
+      return GDB_SIGNAL_STOP;
+
+    case DRAGONFLY_SIGTSTP:
+      return GDB_SIGNAL_TSTP;
+
+    case DRAGONFLY_SIGCONT:
+      return GDB_SIGNAL_CONT;
+
+    case DRAGONFLY_SIGCHLD:
+      return GDB_SIGNAL_CHLD;
+
+    case DRAGONFLY_SIGTTIN:
+      return GDB_SIGNAL_TTIN;
+
+    case DRAGONFLY_SIGTTOU:
+      return GDB_SIGNAL_TTOU;
+
+    case DRAGONFLY_SIGIO:
+      return GDB_SIGNAL_IO;
+
+    case DRAGONFLY_SIGXCPU:
+      return GDB_SIGNAL_XCPU;
+
+    case DRAGONFLY_SIGXFSZ:
+      return GDB_SIGNAL_XFSZ;
+
+    case DRAGONFLY_SIGVTALRM:
+      return GDB_SIGNAL_VTALRM;
+
+    case DRAGONFLY_SIGPROF:
+      return GDB_SIGNAL_PROF;
+
+    case DRAGONFLY_SIGWINCH:
+      return GDB_SIGNAL_WINCH;
+
+    case DRAGONFLY_SIGINFO:
+      return GDB_SIGNAL_INFO;
+
+    case DRAGONFLY_SIGUSR1:
+      return GDB_SIGNAL_USR1;
+
+    case DRAGONFLY_SIGUSR2:
+      return GDB_SIGNAL_USR2;
+
+    /* SIGTHR is the same as SIGLWP on FreeBSD. */
+    case DRAGONFLY_SIGTHR:
+      return GDB_SIGNAL_LWP;
+
+    case DRAGONFLY_SIGLIBRT:
+      return GDB_SIGNAL_LIBRT;
+    }
+
+  return GDB_SIGNAL_UNKNOWN;
+}
+
+/* Implement the "gdb_signal_to_target" gdbarch method.  */
+
+static int
+dfly_gdb_signal_to_target (struct gdbarch *gdbarch,
+		enum gdb_signal signal)
+{
+  switch (signal)
+    {
+    case GDB_SIGNAL_0:
+      return 0;
+
+    case GDB_SIGNAL_HUP:
+      return DRAGONFLY_SIGHUP;
+
+    case GDB_SIGNAL_INT:
+      return DRAGONFLY_SIGINT;
+
+    case GDB_SIGNAL_QUIT:
+      return DRAGONFLY_SIGQUIT;
+
+    case GDB_SIGNAL_ILL:
+      return DRAGONFLY_SIGILL;
+
+    case GDB_SIGNAL_TRAP:
+      return DRAGONFLY_SIGTRAP;
+
+    case GDB_SIGNAL_ABRT:
+      return DRAGONFLY_SIGABRT;
+
+    case GDB_SIGNAL_EMT:
+      return DRAGONFLY_SIGEMT;
+
+    case GDB_SIGNAL_FPE:
+      return DRAGONFLY_SIGFPE;
+
+    case GDB_SIGNAL_KILL:
+      return DRAGONFLY_SIGKILL;
+
+    case GDB_SIGNAL_BUS:
+      return DRAGONFLY_SIGBUS;
+
+    case GDB_SIGNAL_SEGV:
+      return DRAGONFLY_SIGSEGV;
+
+    case GDB_SIGNAL_SYS:
+      return DRAGONFLY_SIGSYS;
+
+    case GDB_SIGNAL_PIPE:
+      return DRAGONFLY_SIGPIPE;
+
+    case GDB_SIGNAL_ALRM:
+      return DRAGONFLY_SIGALRM;
+
+    case GDB_SIGNAL_TERM:
+      return DRAGONFLY_SIGTERM;
+
+    case GDB_SIGNAL_URG:
+      return DRAGONFLY_SIGURG;
+
+    case GDB_SIGNAL_STOP:
+      return DRAGONFLY_SIGSTOP;
+
+    case GDB_SIGNAL_TSTP:
+      return DRAGONFLY_SIGTSTP;
+
+    case GDB_SIGNAL_CONT:
+      return DRAGONFLY_SIGCONT;
+
+    case GDB_SIGNAL_CHLD:
+      return DRAGONFLY_SIGCHLD;
+
+    case GDB_SIGNAL_TTIN:
+      return DRAGONFLY_SIGTTIN;
+
+    case GDB_SIGNAL_TTOU:
+      return DRAGONFLY_SIGTTOU;
+
+    case GDB_SIGNAL_IO:
+      return DRAGONFLY_SIGIO;
+
+    case GDB_SIGNAL_XCPU:
+      return DRAGONFLY_SIGXCPU;
+
+    case GDB_SIGNAL_XFSZ:
+      return DRAGONFLY_SIGXFSZ;
+
+    case GDB_SIGNAL_VTALRM:
+      return DRAGONFLY_SIGVTALRM;
+
+    case GDB_SIGNAL_PROF:
+      return DRAGONFLY_SIGPROF;
+
+    case GDB_SIGNAL_WINCH:
+      return DRAGONFLY_SIGWINCH;
+
+    case GDB_SIGNAL_INFO:
+      return DRAGONFLY_SIGINFO;
+
+    case GDB_SIGNAL_USR1:
+      return DRAGONFLY_SIGUSR1;
+
+    case GDB_SIGNAL_USR2:
+      return DRAGONFLY_SIGUSR2;
+
+    case GDB_SIGNAL_LWP:
+      return DRAGONFLY_SIGTHR;
+
+    case GDB_SIGNAL_LIBRT:
+      return DRAGONFLY_SIGLIBRT;
+    }
+
+  if (signal >= GDB_SIGNAL_REALTIME_65
+      && signal <= GDB_SIGNAL_REALTIME_126)
+    {
+      int offset = signal - GDB_SIGNAL_REALTIME_65;
+
+      return DRAGONFLY_SIGRTMIN + offset;
+    }
+
+  return -1;
+}
+
+
+/* Return description of signal code or nullptr.  */
+
+#if 0
+static const char *
+dfly_signal_cause (enum gdb_signal siggnal, int code)
+{
+  /* Signal-independent causes.  */
+  switch (code)
+    {
+    case DFLY_SI_USER:
+      return _("Sent by kill()");
+    case DFLY_SI_QUEUE:
+      return _("Sent by sigqueue()");
+    case DFLY_SI_TIMER:
+      return _("Timer expired");
+    case DFLY_SI_ASYNCIO:
+      return _("Asynchronous I/O request completed");
+    case DFLY_SI_MESGQ:
+      return _("Message arrived on empty message queue");
+    }
+
+  switch (siggnal)
+    {
+    case GDB_SIGNAL_ILL:
+      switch (code)
+	{
+	case DFLY_ILL_ILLOPC:
+	  return _("Illegal opcode");
+	case DFLY_ILL_ILLOPN:
+	  return _("Illegal operand");
+	case DFLY_ILL_ILLADR:
+	  return _("Illegal addressing mode");
+	case DFLY_ILL_ILLTRP:
+	  return _("Illegal trap");
+	case DFLY_ILL_PRVOPC:
+	  return _("Privileged opcode");
+	case DFLY_ILL_PRVREG:
+	  return _("Privileged register");
+	case DFLY_ILL_COPROC:
+	  return _("Coprocessor error");
+	case DFLY_ILL_BADSTK:
+	  return _("Internal stack error");
+	}
+      break;
+    case GDB_SIGNAL_BUS:
+      switch (code)
+	{
+	case DFLY_BUS_ADRALN:
+	  return _("Invalid address alignment");
+	case DFLY_BUS_ADRERR:
+	  return _("Address not present");
+	case DFLY_BUS_OBJERR:
+	  return _("Object-specific hardware error");
+	}
+      break;
+    case GDB_SIGNAL_SEGV:
+      switch (code)
+	{
+	case DFLY_SEGV_MAPERR:
+	  return _("Address not mapped to object");
+	case DFLY_SEGV_ACCERR:
+	  return _("Invalid permissions for mapped object");
+	}
+      break;
+    case GDB_SIGNAL_FPE:
+      switch (code)
+	{
+	case DFLY_FPE_INTOVF:
+	  return _("Integer overflow");
+	case DFLY_FPE_INTDIV:
+	  return _("Integer divide by zero");
+	case DFLY_FPE_FLTDIV:
+	  return _("Floating point divide by zero");
+	case DFLY_FPE_FLTOVF:
+	  return _("Floating point overflow");
+	case DFLY_FPE_FLTUND:
+	  return _("Floating point underflow");
+	case DFLY_FPE_FLTRES:
+	  return _("Floating point inexact result");
+	case DFLY_FPE_FLTINV:
+	  return _("Invalid floating point operation");
+	case DFLY_FPE_FLTSUB:
+	  return _("Subscript out of range");
+	}
+      break;
+    case GDB_SIGNAL_TRAP:
+      switch (code)
+	{
+	case DFLY_TRAP_BRKPT:
+	  return _("Breakpoint");
+	case DFLY_TRAP_TRACE:
+	  return _("Trace trap");
+	}
+      break;
+    case GDB_SIGNAL_CHLD:
+      switch (code)
+	{
+	case DFLY_CLD_EXITED:
+	  return _("Child has exited");
+	case DFLY_CLD_KILLED:
+	  return _("Child has terminated abnormally");
+	case DFLY_CLD_DUMPED:
+	  return _("Child has dumped core");
+	case DFLY_CLD_TRAPPED:
+	  return _("Traced child has trapped");
+	case DFLY_CLD_STOPPED:
+	  return _("Child has stopped");
+	case DFLY_CLD_CONTINUED:
+	  return _("Stopped child has continued");
+	}
+      break;
+    case GDB_SIGNAL_POLL:
+      switch (code)
+	{
+	case DFLY_POLL_IN:
+	  return _("Data input available");
+	case DFLY_POLL_OUT:
+	  return _("Output buffers available");
+	case DFLY_POLL_MSG:
+	  return _("Input message available");
+	case DFLY_POLL_ERR:
+	  return _("I/O error");
+	case DFLY_POLL_PRI:
+	  return _("High priority input available");
+	case DFLY_POLL_HUP:
+	  return _("Device disconnected");
+	}
+      break;
+    }
+
+  return nullptr;
+}
+#endif
+
+/* Print descriptions of DragonFly-specific AUXV entries to FILE.  */
+
+static void
+dfly_print_auxv_entry (struct gdbarch *gdbarch, struct ui_file *file,
+		       CORE_ADDR type, CORE_ADDR val)
+{
+  const char *name = "???";
+  const char *description = "";
+  enum auxv_format format = AUXV_FORMAT_HEX;
+
+  switch (type)
+    {
+    case AT_NULL:
+    case AT_IGNORE:
+    case AT_EXECFD:
+    case AT_PHDR:
+    case AT_PHENT:
+    case AT_PHNUM:
+    case AT_PAGESZ:
+    case AT_BASE:
+    case AT_FLAGS:
+    case AT_ENTRY:
+    case AT_NOTELF:
+    case AT_UID:
+    case AT_EUID:
+    case AT_GID:
+    case AT_EGID:
+      default_print_auxv_entry (gdbarch, file, type, val);
+      return;
+#define _TAGNAME(tag) #tag
+#define TAGNAME(tag) _TAGNAME(AT_##tag)
+#define TAG(tag, text, kind) \
+      case AT_FREEBSD_##tag: name = TAGNAME(tag); description = text; format = kind; break
+      TAG (EXECPATH, _("Executable path"), AUXV_FORMAT_STR);
+      TAG (CANARY, _("Canary for SSP"), AUXV_FORMAT_HEX);
+      TAG (CANARYLEN, ("Length of the SSP canary"), AUXV_FORMAT_DEC);
+      TAG (OSRELDATE, _("OSRELDATE"), AUXV_FORMAT_DEC);
+      TAG (NCPUS, _("Number of CPUs"), AUXV_FORMAT_DEC);
+      TAG (PAGESIZES, _("Pagesizes"), AUXV_FORMAT_HEX);
+      TAG (PAGESIZESLEN, _("Number of pagesizes"), AUXV_FORMAT_DEC);
+      TAG (STACKPROT, _("Initial stack protection"), AUXV_FORMAT_HEX);
+      TAG (EHDRFLAGS, _("ELF header e_flags"), AUXV_FORMAT_HEX);
+      TAG (HWCAP, _("Machine-dependent CPU capability hints"), AUXV_FORMAT_HEX);
+      TAG (HWCAP2, _("Extension of AT_HWCAP"), AUXV_FORMAT_HEX);
+      TAG (BSDFLAGS, _("ELF BSD flags"), AUXV_FORMAT_HEX);
+      TAG (ARGC, _("Argument count"), AUXV_FORMAT_DEC);
+      TAG (ARGV, _("Argument vector"), AUXV_FORMAT_HEX);
+      TAG (ENVC, _("Environment count"), AUXV_FORMAT_DEC);
+      TAG (ENVV, _("Environment vector"), AUXV_FORMAT_HEX);
+      TAG (PS_STRINGS, _("Pointer to ps_strings"), AUXV_FORMAT_HEX);
+      TAG (FXRNG, _("Pointer to root RNG seed version"), AUXV_FORMAT_HEX);
+      TAG (KPRELOAD, _("Base address of vDSO"), AUXV_FORMAT_HEX);
+      TAG (USRSTACKBASE, _("Top of user stack"), AUXV_FORMAT_HEX);
+      TAG (USRSTACKLIM, _("Grow limit of user stack"), AUXV_FORMAT_HEX);
+    }
+
+  fprint_auxv_entry (file, name, description, format, type, val);
+}
+
+
+/* See fbsd-tdep.h.  */
+
+CORE_ADDR
+dfly_skip_solib_resolver (struct gdbarch *gdbarch, CORE_ADDR pc)
+{
+  struct bound_minimal_symbol msym = lookup_bound_minimal_symbol ("_rtld_bind");
+  if (msym.minsym != nullptr && msym.value_address () == pc)
+    return frame_unwind_caller_pc (get_current_frame ());
+
+  return 0;
+}
+
+
+
+/* To be called from GDB_OSABI_DRAGONFLY handlers. */
+
+void
+dfly_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+#if 0
+  set_gdbarch_core_pid_to_str (gdbarch, dfly_core_pid_to_str);
+  set_gdbarch_core_thread_name (gdbarch, dfly_core_thread_name);
+  set_gdbarch_core_xfer_siginfo (gdbarch, dfly_core_xfer_siginfo);
+  set_gdbarch_make_corefile_notes (gdbarch, dfly_make_corefile_notes);
+  set_gdbarch_core_info_proc (gdbarch, dfly_core_info_proc);
+  set_gdbarch_get_siginfo_type (gdbarch, dfly_get_siginfo_type);
+#endif
+  set_gdbarch_print_auxv_entry (gdbarch, dfly_print_auxv_entry);
+  set_gdbarch_gdb_signal_from_target (gdbarch, dfly_gdb_signal_from_target);
+  set_gdbarch_gdb_signal_to_target (gdbarch, dfly_gdb_signal_to_target);
+  set_gdbarch_skip_solib_resolver (gdbarch, dfly_skip_solib_resolver);
+
+#if 0
+  set_gdbarch_report_signal_info (gdbarch, dfly_report_signal_info);
+  set_gdbarch_vsyscall_range (gdbarch, dfly_vsyscall_range);
+
+  /* `catch syscall' */
+  set_xml_syscall_file_name (gdbarch, "syscalls/dragonfly.xml");
+  set_gdbarch_get_syscall_number (gdbarch, dfly_get_syscall_number);
+#endif
+}
--- /dev/null
+++ gdb/dfly-tdep.h
@@ -0,0 +1,30 @@
+/* Target-dependent code for DragonBSD, architecture independent.
+
+   Copyright (C) 2009-2023 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef DFLY_TDEP_H
+#define DFLY_TDEP_H
+
+extern void dfly_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch);
+
+/* Implement the "skip_solib_resolver" gdbarch method.  */
+
+extern CORE_ADDR dfly_skip_solib_resolver (struct gdbarch *gdbarch,
+					   CORE_ADDR pc);
+
+#endif /* dfly-tdep.h */
--- /dev/null
+++ gdb/i386-dfly-tdep.c
@@ -0,0 +1,111 @@
+/* Target-dependent code for DragonFly/i386.
+
+   Copyright (C) 2003-2023 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "osabi.h"
+#include "regcache.h"
+#include "regset.h"
+#include "gdbsupport/x86-xstate.h"
+
+#include "i386-tdep.h"
+#include "i387-tdep.h"
+#include "dfly-tdep.h"
+#include "solib-svr4.h"
+#include "inferior.h"
+
+static int i386dfly_r_reg_offset[] =
+{
+  44, /* %eax */
+  40, /* %ecx */
+  36, /* %edx */
+  32, /* %ebx */
+  72, /* %esp */
+  24, /* %ebp */
+  20, /* %esi */
+  16, /* %edi */
+  60, /* %eip */
+  68, /* %eflags */
+  64, /* %cs */
+  76, /* %ss */
+  12, /* %ds */
+  8, /* %es */
+  4, /* %fs */
+  0  /* %gs */
+};
+
+
+/* Sigtramp routine location.  */
+CORE_ADDR i386dfly_sigtramp_start_addr = 0xbfbfdf20;
+CORE_ADDR i386dfly_sigtramp_end_addr = 0xbfbfdff0;
+
+int i386dfly_sc_reg_offset[] =
+{
+  64, /* %eax */
+  60, /* %ecx */
+  56, /* %edx */
+  52, /* %ebx */
+  92, /* %esp */
+  44, /* %ebp */
+  40, /* %esi */
+  36, /* %edi */
+  80, /* %eip */
+  88, /* %eflags */
+  84, /* %cs */
+  96, /* %ss */
+  32, /* %ds */
+  28, /* %es */
+  24, /* %fs */
+  20  /* %gs */
+};
+
+
+static void
+i386dfly_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+{
+  i386_gdbarch_tdep *tdep = gdbarch_tdep<i386_gdbarch_tdep> (gdbarch);
+
+  /* Generic DragonFly support. */
+  dfly_init_abi (info, gdbarch);
+
+  /* Obviously DragonFly is BSD-based.  */
+  i386bsd_init_abi (info, gdbarch);
+
+  i386_elf_init_abi (info, gdbarch);
+
+  tdep->gregset_reg_offset = i386dfly_r_reg_offset;
+  tdep->gregset_num_regs = ARRAY_SIZE (i386dfly_r_reg_offset);
+  tdep->sizeof_gregset = 80;
+
+  tdep->sc_reg_offset = i386dfly_sc_reg_offset;
+  tdep->sc_num_regs = ARRAY_SIZE (i386dfly_sc_reg_offset);
+
+  /* DragonFly uses SVR4-style shared libraries.  */
+  set_solib_svr4_fetch_link_map_offsets
+    (gdbarch, svr4_ilp32_fetch_link_map_offsets);
+
+}
+
+void _initialize_i386dfly_tdep ();
+
+void
+_initialize_i386dfly_tdep ()
+{
+  gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_DRAGONFLY,
+			  i386dfly_init_abi);
+}
--- gdb/aarch64-linux-tdep.c.orig
+++ gdb/aarch64-linux-tdep.c
@@ -1775,13 +1775,13 @@
     return;
 
   CORE_ADDR fault_addr = 0;
-  long si_code = 0;
+  long db_si_code = 0;
 
   try
     {
       /* Sigcode tells us if the segfault is actually a memory tag
 	 violation.  */
-      si_code = parse_and_eval_long ("$_siginfo.si_code");
+      db_si_code = parse_and_eval_long ("$_siginfo.si_code");
 
       fault_addr
 	= parse_and_eval_long ("$_siginfo._sifields._sigfault.si_addr");
@@ -1793,7 +1793,7 @@
     }
 
   /* If this is not a memory tag violation, just return.  */
-  if (si_code != SEGV_MTEAERR && si_code != SEGV_MTESERR)
+  if (db_si_code != SEGV_MTEAERR && db_si_code != SEGV_MTESERR)
     return;
 
   uiout->text ("\n");
@@ -1801,7 +1801,7 @@
   uiout->field_string ("sigcode-meaning", _("Memory tag violation"));
 
   /* For synchronous faults, show additional information.  */
-  if (si_code == SEGV_MTESERR)
+  if (db_si_code == SEGV_MTESERR)
     {
       uiout->text (_(" while accessing address "));
       uiout->field_core_addr ("fault-addr", gdbarch, fault_addr);
--- gdb/bsd-kvm.c.orig
+++ gdb/bsd-kvm.c
@@ -328,7 +328,9 @@
 #ifdef HAVE_STRUCT_LWP
   addr += offsetof (struct lwp, l_addr);
 #else
+# ifndef __DragonFly__  /* XXX FIXME */
   addr += offsetof (struct proc, p_addr);
+# endif
 #endif
 
   if (kvm_read (core_kd, addr, &bsd_kvm_paddr, sizeof bsd_kvm_paddr) == -1)
--- gdb/configure.host.orig
+++ gdb/configure.host
@@ -175,6 +175,7 @@
 vax-*-openbsd*)		gdb_host=obsd ;;
 
 x86_64-*-linux*)	gdb_host=linux64 ;;
+x86_64-*-dragonfly*)	gdb_host=dfly64 ;;
 x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)
 			gdb_host=fbsd64 ;;
 x86_64-*-netbsd* | x86_64-*-knetbsd*-gnu)
--- gdb/configure.nat.orig
+++ gdb/configure.nat
@@ -62,6 +62,11 @@
 	NAT_CDEPS='$(srcdir)/proc-service.list'
 	LOADLIBES='-ldl $(RDYNAMIC)'
 	;;
+    dfly*)
+	NATDEPFILES='fork-child.o nat/fork-inferior.o inf-ptrace.o dfly-nat.o'
+	HAVE_NATIVE_GCORE_HOST=1
+	LOADLIBES='-lkvm'
+	;;
     fbsd*)
 	NATDEPFILES='fork-child.o nat/fork-inferior.o inf-ptrace.o fbsd-nat.o'
 	HAVE_NATIVE_GCORE_HOST=1
@@ -189,6 +194,16 @@
 		;;
 	esac
 	;;
+    dfly64)
+	case ${gdb_host_cpu} in
+	    i386)
+		# Host: DragonFly/amd64
+		NATDEPFILES="${NATDEPFILES} amd64-nat.o \
+		amd64-dfly-nat.o bsd-kvm.o x86-nat.o nat/x86-dregs.o \
+		x86-bsd-nat.o"
+		;;
+	esac
+	;;
     fbsd64)
 	case ${gdb_host_cpu} in
 	    i386)
--- gdb/configure.tgt.orig
+++ gdb/configure.tgt
@@ -114,6 +114,8 @@
 # 2. Get the objects per os in $TARG.
 
 case "${targ}" in
+*-*-dragonfly*)
+	os_obs="dfly-tdep.o solib-svr4.o";;
 *-*-freebsd* | *-*-kfreebsd*-gnu)
 	os_obs="fbsd-tdep.o solib-svr4.o";;
 *-*-netbsd* | *-*-knetbsd*-gnu)
@@ -706,6 +708,11 @@
 			i386-linux-tdep.o glibc-tdep.o \
 			solib-svr4.o symfile-mem.o linux-tdep.o linux-record.o"
 	;;
+x86_64-*-dragonfly*)
+	# Target: DragonFly/amd64
+	gdb_target_obs="amd64-dfly-tdep.o ${i386_tobjs} \
+			i386-bsd-tdep.o i386-dfly-tdep.o"
+	;;
 x86_64-*-freebsd* | x86_64-*-kfreebsd*-gnu)
 	# Target: FreeBSD/amd64
 	gdb_target_obs="amd64-fbsd-tdep.o ${i386_tobjs} \
@@ -785,6 +792,8 @@
 # map target onto default OS ABI
 
 case "${targ}" in
+*-*-dragonfly*)
+		gdb_osabi=GDB_OSABI_DRAGONFLY ;;
 *-*-freebsd* | *-*-kfreebsd*-gnu)
 		gdb_osabi=GDB_OSABI_FREEBSD ;;
 *-*-linux* | *-*-uclinux*)
--- gdb/fbsd-nat.c.orig
+++ gdb/fbsd-nat.c
@@ -1130,6 +1130,14 @@
       /* If ptid is a specific LWP, suspend all other LWPs in the process.  */
       inferior *inf = find_inferior_ptid (this, ptid);
 
+#ifndef PT_LWP_EVENTS
+      /* When LWP events are not supported, a new thread might already be
+	 running that has not yet reported an event when GDB wishes to
+	 only run a single thread.  Force an update of the thread list
+	 to ensure that any such threads are suspended before the process
+	 is resumed.  */
+      fbsd_add_threads (ptid.pid ());
+#endif
       for (thread_info *tp : inf->non_exited_threads ())
 	{
 	  int request;
--- gdb/gdb.c.orig
+++ gdb/gdb.c
@@ -28,6 +28,12 @@
   memset (&args, 0, sizeof args);
   args.argc = argc;
   args.argv = argv;
-  args.interpreter_p = INTERP_CONSOLE;
+  if (strncmp(basename(argv[0]), "insight", 7) == 0) {
+    args.interpreter_p = "insight";
+  } else if (strncmp(basename(argv[0]), "gdbtui", 6) == 0) {
+    args.interpreter_p = INTERP_TUI;
+  } else {
+    args.interpreter_p = INTERP_CONSOLE;
+  }
   return gdb_main (&args);
 }
--- gdb/gdb_wchar.h.orig
+++ gdb/gdb_wchar.h
@@ -59,7 +59,7 @@
    iconvlist.  */
 #if defined (HAVE_ICONV) && defined (HAVE_BTOWC) \
   && (defined (__STDC_ISO_10646__) \
-      || (defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108))
+      || (!defined (LIBICONV_PLUG) && defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108))
 
 typedef wchar_t gdb_wchar_t;
 typedef wint_t gdb_wint_t;
@@ -82,7 +82,7 @@
 #define INTERMEDIATE_ENCODING intermediate_encoding ()
 const char *intermediate_encoding (void);
 
-#elif defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108
+#elif !defined (LIBICONV_PLUG) && defined (_LIBICONV_VERSION) && _LIBICONV_VERSION >= 0x108
 #define INTERMEDIATE_ENCODING "wchar_t"
 #else
 /* This shouldn't happen, because the earlier #if should have filtered
--- gdb/i386-fbsd-nat.c.orig
+++ gdb/i386-fbsd-nat.c
@@ -41,8 +41,6 @@
   void store_registers (struct regcache *, int) override;
 
   const struct target_desc *read_description () override;
-
-  void resume (ptid_t, int, enum gdb_signal) override;
 };
 
 static i386_fbsd_nat_target the_i386_fbsd_nat_target;
@@ -221,6 +219,7 @@
     perror_with_name (_("Couldn't write floating point status"));
 }
 
+#if 0
 /* Resume execution of the inferior process.  If STEP is nonzero,
    single-step it.  If SIGNAL is nonzero, give it that signal.  */
 
@@ -267,6 +266,7 @@
 	      gdb_signal_to_host (signal)) == -1)
     perror_with_name (("ptrace"));
 }
+#endif
 
 
 /* Support for debugging kernel virtual memory images.  */
--- gdb/inflow.c.orig
+++ gdb/inflow.c
@@ -854,7 +854,10 @@
 pass_signal (int signo)
 {
 #ifndef _WIN32
-  kill (inferior_ptid.pid (), SIGINT);
+  if (inferior_ptid.pid () )
+    kill (inferior_ptid.pid (), SIGINT);
+  else
+    kill (current_inferior ()->pid, SIGINT);
 #endif
 }
 
--- gdb/osabi.c.orig
+++ gdb/osabi.c
@@ -69,6 +69,7 @@
   { "FreeBSD", NULL },
   { "NetBSD", NULL },
   { "OpenBSD", NULL },
+  { "DragonFly", NULL },
   { "WindowsCE", NULL },
   { "DJGPP", NULL },
   { "QNX-Neutrino", NULL },
@@ -516,6 +517,15 @@
 	  return;
 	}
 
+      /* DragonFly.  */
+      if (check_note (abfd, sect, note, &sectsize, "DragonFly", 4,
+		      NT_DRAGONFLY_ABI_TAG))
+	{
+	  /* There is no need to check the version yet.  */
+	  *osabi = GDB_OSABI_DRAGONFLY;
+	  return;
+	}
+
       /* FreeBSD.  */
       if (check_note (abfd, sect, note, &sectsize, "FreeBSD", 4,
 		      NT_FREEBSD_ABI_TAG))
--- gdb/osabi.h.orig
+++ gdb/osabi.h
@@ -33,6 +33,7 @@
   GDB_OSABI_FREEBSD,
   GDB_OSABI_NETBSD,
   GDB_OSABI_OPENBSD,
+  GDB_OSABI_DRAGONFLY,
   GDB_OSABI_WINCE,
   GDB_OSABI_GO32,
   GDB_OSABI_QNXNTO,
--- gdb/python/python-config.py.orig
+++ gdb/python/python-config.py
@@ -65,6 +65,8 @@
 
     elif opt in ("--libs", "--ldflags"):
         libs = ["-lpython" + pyver + abiflags]
+        if getvar('LDFLAGS') is not None:
+            libs.extend(getvar('LDFLAGS').split())
         if getvar("LIBS") is not None:
             libs.extend(getvar("LIBS").split())
         if getvar("SYSLIBS") is not None:
--- gdb/s390-tdep.c.orig
+++ gdb/s390-tdep.c
@@ -41,6 +41,10 @@
 #include "value.h"
 #include "inferior.h"
 
+#ifdef __sun__
+#undef CS
+#endif
+
 #include "features/s390-linux32.c"
 #include "features/s390x-linux64.c"
 
--- gdb/sparc64-linux-tdep.c.orig
+++ gdb/sparc64-linux-tdep.c
@@ -129,14 +129,14 @@
     return;
 
   CORE_ADDR addr = 0;
-  long si_code = 0;
+  long db_si_code = 0;
 
   try
     {
-      /* Evaluate si_code to see if the segfault is ADI related.  */
-      si_code = parse_and_eval_long ("$_siginfo.si_code\n");
+      /* Evaluate db_si_code to see if the segfault is ADI related.  */
+      db_si_code = parse_and_eval_long ("$_siginfo.si_code\n");
 
-      if (si_code >= SEGV_ACCADI && si_code <= SEGV_ADIPERR)
+      if (db_si_code >= SEGV_ACCADI && db_si_code <= SEGV_ADIPERR)
 	addr = parse_and_eval_long ("$_siginfo._sifields._sigfault.si_addr");
     }
   catch (const gdb_exception &exception)
@@ -145,7 +145,7 @@
     }
 
   /* Print out ADI event based on sig_code value */
-  switch (si_code)
+  switch (db_si_code)
     {
     case SEGV_ACCADI:	/* adi not enabled */
       uiout->text ("\n");
